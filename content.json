{"meta":{"title":"Kalan","subtitle":null,"description":null,"author":"Kalan","url":"https://kalanliao.github.io","root":"/"},"pages":[],"posts":[{"title":".NetCore3.0预览","slug":"netcore/netcore3.0_preview","date":"2019-09-17T08:55:49.000Z","updated":"2019-09-17T09:02:06.000Z","comments":true,"path":"2019/09/17/netcore/netcore3.0_preview/","link":"","permalink":"https://kalanliao.github.io/2019/09/17/netcore/netcore3.0_preview/","excerpt":"","text":".NET Core 3.0 正式发布将在.NET Conf 上发布，.NET Conf 时间是9月23日至25日。 Visual Studio 2019 16.3预览版3和Visual Studio for Mac 8.3支持.NET Core 3.0 ，这些版本也同时发布。 从.NET Core 3.0 Preview 7就可用于生产，目前dotnet官网就是使用 https://dotnet.microsoft.com/ Powered by .NET Core 3.0.0-preview9-19423-09。 博客园也升级为.NET Core 3.0 Preview 8，目前运行算是良好。 下面实际体验.NET Core 3.0 新特性。.NET Core 3.0System.Text.Json1234567891011121314public class Person&#123; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public DateTime? BirthDay &#123; get; set; &#125;&#125;//转成对象string json = ...Person person = JsonSerializer.Parse&lt;Person&gt;(json);//转成json字符串Person person = ...string json = JsonSerializer.ToString(person); .NET Standard 2.1要以.NET Standard 2.1为目标，必须编辑项目文件并将TargetFramework属性更改为netstandard2.1： .NET Framework不支持.NET Standard 2.1。 12345&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; Microsoft.Data.SqlClientMicrosoft.Data.SqlClient是Microsoft Sql Server的数据提供程序。 它是两个System.Data.SqlClient组件的联合体，独立存在于.NET Framework和.NET Core中。 最新版本安装 Install-Package Microsoft.Data.SqlClient https://github.com/dotnet/SqlClient 发布成单个程序dotnet publish -r win10-x64 /p:PublishSingleFile=true Alpine Docker images.NET Core and ASP.NET Core on ARM64 docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8 docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8 dotnet-counters安装 ： dotnet tool install –global dotnet-counters –version 3.0.0-preview8.19412.1 使用示例： 显示所有信息 dotnet-counters monitor –process-id 1902 System.Runtime 显示CPU使用 GC 及异常数 dotnet-counters monitor –process-id 1902 System.Runtime[cpu-usage,gc-heap-size,exception-count] 官方文档：https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md ReadyToRun你可以通过将应用程序集编译为ReadyToRun（R2R）格式来缩短.NET Core应用程序的启动时间。R2R是一种提前（AOT）编译的形式。 示例提升： 仅限IL的应用： 启动时间：1.9秒内存使用量：69.1 MB应用程序大小：150 MB使用ReadyToRun图像： 启动时间：1.3秒。内存使用量：55.7 MB应用程序大小：156 MB要启用ReadyToRun编译 需要以下操作： 将PublishReadyToRun属性设置为true。 使用显式发布RuntimeIdentifier。 1234567&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;true&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; dotnet publish -r win-x64 -c Release ReadyToRun编译器目前不支持交叉定位。需要在给定目标上进行编译。例如，如果想要Windows x64的R2R程序，则需要在该环境中运行publish命令。 IL linker使用IL linker 可以将程序大小从大约68MB减少到大约28MB dotnet publish -r win10-x64 -c Release /p:PublishTrimmed=true /p:PublishSingleFile=true HttpClient支持HTTP/2123456789101112var client = new HttpClient() &#123; BaseAddress = new Uri(&quot;https://localhost:5001&quot;) &#125;;// HTTP/1.1 requestusing (var response = await client.GetAsync(&quot;/&quot;))&#123; Console.WriteLine(response.Content);&#125;// HTTP/2 requestusing (var request = new HttpRequestMessage(HttpMethod.Get, &quot;/&quot;) &#123; Version = new Version(2, 0) &#125;)using (var response = await client.SendAsync(request))&#123; Console.WriteLine(response.Content);&#125; ASP.NET Core 3.0ASP.NET Core 3.0中主要更新还是Blazor和gRPC BlazorBlazor 是一个用于使用 .NET 生成交互式客户端 Web UI 的框架： 使用 C# 代替 JavaScript 来创建丰富的交互式 UI。 共享使用 .NET 编写的服务器端和客户端应用逻辑。 将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。 使用 .NET 进行客户端 Web 开发可提供以下优势： 使用 C# 代替 JavaScript 来编写代码。 利用现有的 .NET 库生态系统。 在服务器和客户端之间共享应用逻辑。 受益于 .NET 的性能、可靠性和安全性。 始终高效支持 Windows、Linux 和 macOS 上的 Visual Studio。 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。 Blazor 应用基于组件 。 Blazor 中的组件是指 UI 元素，例如，页面、对话框或数据输入窗体。 组件类通常以 Razor 标记页（文件扩展名为 .razor ）的形式编写。 Blazor 中的组件有时被称为 Razor 组件 。 Razor 标记演示组件： 1234567891011121314151617&lt;div&gt; &lt;h1&gt;@Title&lt;/h1&gt; @ChildContent &lt;button @onclick=&quot;OnYes&quot;&gt;Yes!&lt;/button&gt;&lt;/div&gt;@code &#123; [Parameter] public string Title &#123; get; set; &#125; [Parameter] public RenderFragment ChildContent &#123; get; set; &#125; private void OnYes() &#123; Console.WriteLine(&quot;Write to the console in C#! &apos;Yes&apos; button was selected.From LineZero&quot;); &#125; 对话框的正文内容 (ChildContent) 和标题 (Title) 由在其 UI 中使用此组件的组件提供。 OnYes 是由按钮的 onclick 事件触发的 C# 方法。 Blazor 使用 UI 构成的自然 HTML 标记。 HTML 元素指定组件，并且标记的特性将值传递给组件的属性。 在以下示例中，Index 组件中使用上面的 Dialog 组件。 1234567@page &quot;/&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;Welcome to your new app.&lt;Dialog Title=&quot;Blazor&quot;&gt; Do you want to &lt;i&gt;learn more&lt;/i&gt; about Blazor? From LineZero&lt;/Dialog&gt; 更多官方介绍：https://docs.microsoft.com/zh-cn/aspnet/core/blazor/get-started?view=aspnetcore-3.0&amp;tabs=visual-studio gRPCgRPC 的主要优点是： 现代高性能轻量级 RPC 框架。 协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。 可用于多种语言的工具，以生成强类型服务器和客户端。 支持客户端、服务器和双向流式处理调用。 使用 Protobuf 二进制序列化减少对网络的使用。 这些优点使 gRPC 适用于： 效率至关重要的轻量级微服务。 需要多种语言用于开发的 Polyglot 系统。 需要处理流式处理请求或响应的点对点实时服务。 虽然 C# 实现目前在官方 gRPC 上有介绍，但当前实现依赖于用 C (gRPC C-core) 编写的本机库。 目前正在基于 Kestrel HTTP 服务器和完全托管的 ASP.NET Core 实现gRPC。","categories":[{"name":".NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/categories/NetCore/"}],"tags":[{"name":"C#,.netcore,.netcore3.0","slug":"C-netcore-netcore3-0","permalink":"https://kalanliao.github.io/tags/C-netcore-netcore3-0/"}]},{"title":"javascript学习-01(Console)","slug":"javascript/javascript-study-01","date":"2019-09-17T06:55:49.000Z","updated":"2019-09-17T08:29:18.193Z","comments":true,"path":"2019/09/17/javascript/javascript-study-01/","link":"","permalink":"https://kalanliao.github.io/2019/09/17/javascript/javascript-study-01/","excerpt":"","text":"Console我们经常会在浏览器中使用console.log来进行调试和参数的输出查看，但是console其实是一个非常丰富的封装，其中还有很多的方法，今天就来介绍一下。首先，我们先看一下console的代码 下面就介绍一下，我们会用到的可以提高我们开发效率，调试效率的方法。 console.log()123456//平时我们使用的时候会这样console.log(\"测试内容不要当真\");//或者这样console.log(1,2,3,4)//或者这样console.log(&#123;name:1&#125;) 上面我们使用的格式为console.log(object),console.log(object, otherObject, string)除了这些基础用法还有比较好玩的用法console.log(msg, values),这个格式的用法有点像C++的printf,C#的Console.Write()等那么我们来看看怎么使用 12345//首先我们使用了3种占位符console.log(\"我今天吃了%o,你吃了%d顿,你叫%s.\", \"Skittles\", 22,\"Kalan\");//%o的复杂传值console.log(\"abc %o\",&#123;name:1&#125;) 我们看一下效果可以看到%o这个是对象占位符,%s这个是字符串占位符,%d这个是数字占位符 下面我们讲解一个更好玩的占位符%c，先上代码 1234console.log( \"我爱你 %c路西\" one day, \"color: Red; background-color: orange; padding: 2px 5px; border-radius: 2px\"); 看到这里，应该明白，这个占位符当你使用之后，后面所有的文字都将根据此CSS渲染%o除外 console.dir()123//直接上例子console.dir(document.getElementsByClassName(\"full\")[0])console.log(document.getElementsByClassName(\"full\")[0]) 我们看到结果console.log直接输出的html，而console.dir输出的是DOM结构树对象 console.warn()这个函数直接会输出一个警告框，可以定位到输出位置 console.table()这个函数能更好的显示列表型数据，我们用console.log显示对比一下 12console.table([1,2,3],[2,3,4])console.table(&#123;name:1,age:2&#125;,&#123;name:11,age:22&#125;,&#123;name:11,age:22&#125;) console.assert() 可以传递2个参数：如果为false会输出Assertion failed和第二个参数（如上图所示） console.countcount只是作为一个计数器，或者作为一个命名计数器，可以统计代码被执行的次数。 1234567891011for (let i = 0; i &lt; 10000; i++) &#123; if (i % 2) &#123; console.count(\"odds\"); &#125; if (!(i % 5)) &#123; console.count(\"multiplesOfFive\"); &#125; if (isPrime(i)) &#123; console.count(\"prime\"); &#125;&#125; console.trace()trace 可以调试模块之间的调用 1234567891011export default class CupcakeService &#123; constructor(dataLib) &#123; this.dataLib = dataLib; if(typeof dataLib !== 'object') &#123; console.log(dataLib); console.trace(); &#125; &#125; ...&#125; 这里使用 console.log()仅告诉我们传递数据dataLib是什么 ，而没有具体的传递的路径。不过，console.trace()会非常清楚地告诉我们问题出在 Dashboard.js，我们可以看到是 new CupcakeService(false)导致错误。 console.time()console.time() 是一个用于跟踪操作时间的专用函数，它是跟踪 JavaScript 执行时间的好方法。 123456789101112131415function slowFunction(number) &#123; var functionTimerStart = new Date().getTime(); // something slow or complex with the numbers. // Factorials, or whatever. var functionTime = new Date().getTime() - functionTimerStart; console.log(`Function time: $&#123;functionTime&#125;`);&#125;var start = new Date().getTime();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;var time = new Date().getTime() - start;console.log(`Execution time: $&#123;time&#125;`); 这是一种老派的做法，我们使用 console.time()来简化以上代码。 123456789101112const slowFunction = number =&gt; &#123; console.time(\"slowFunction\"); // something slow or complex with the numbers. // Factorials, or whatever. console.timeEnd(\"slowFunction\");&#125;;console.time();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;console.timeEnd(); console.group()12345678910111213// this is the global scopelet number = 1;console.group(\"OutsideLoop\");console.log(number);console.group(\"Loop\");for (let i = 0; i &lt; 5; i++) &#123; number = i + number; console.log(number);&#125;console.groupEnd();console.log(number);console.groupEnd();console.log(\"All done now\"); 输出如下： 123456789101112131415161718class MyClass &#123; constructor(dataAccess) &#123; console.group(\"Constructor\"); console.log(\"Constructor executed\"); console.assert( typeof dataAccess === \"object\", \"Potentially incorrect dataAccess object\" ); this.initializeEvents(); console.groupEnd(); &#125; initializeEvents() &#123; console.group(\"events\"); console.log(\"Initialising events\"); console.groupEnd(); &#125;&#125;let myClass = new MyClass(false);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kalanliao.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://kalanliao.github.io/tags/js/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-17T03:13:05.858Z","updated":"2019-09-17T05:38:34.554Z","comments":true,"path":"2019/09/17/hello-world/","link":"","permalink":"https://kalanliao.github.io/2019/09/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"测试","slug":"测试","permalink":"https://kalanliao.github.io/categories/测试/"}],"tags":[]}]}
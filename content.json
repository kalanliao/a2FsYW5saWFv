{"meta":{"title":"Kalan","subtitle":null,"description":null,"author":"Kalan","url":"https://kalanliao.github.io","root":"/"},"pages":[],"posts":[{"title":".NET Core 3.0 发布(新功能整理)","slug":"netcore/netcore3-0-public","date":"2019-09-24T06:59:07.000Z","updated":"2019-09-24T07:22:54.268Z","comments":true,"path":"2019/09/24/netcore/netcore3-0-public/","link":"","permalink":"https://kalanliao.github.io/2019/09/24/netcore/netcore3-0-public/","excerpt":"","text":"很高兴宣布.NET Core 3.0的发布。它包括许多改进，包括添加Windows窗体和WPF，添加新的JSON API，对ARM64的支持以及全面提高的性能。 C# 8 也是此发行版的一部分，其中包括可为空，异步流和更多模式。包含F＃4.7专注于放宽语法并定位.NET Standard 2.0。 可以立即开始将现有项目更新为目标.NET Core 3.0。该版本与以前的版本兼容，从而使更新变得容易。 观看团队和社区在.NET Conf上谈论.NET的事情，现在直播（https://www.dotnetconf.net/）！ 可以下载适用于Windows，macOS和Linux的.NET Core 3.0： .NET Core 3.0 SDK和运行时（https://dotnet.microsoft.com/download/dotnet-core/3.0） Snap安装程序 Docker映像 ASP.NET Core 3.0和EF Core 3.0也发布 Visual Studio 2019 16.3和适用于Mac 8.3的Visual Studio也在今天发布，并且需要更新才能将.NET Core 3.0与Visual Studio一起使用。 .NET Core 3.0是Visual Studio 2019 16.3的一部分。只需升级Visual Studio 2019 16.3就可以获取.NET Core。 感谢所有为.NET Core 3.0做出贡献的人！数百人参与了此版本的发布，包括社区的重大贡献。 发行说明： .NET Core 3.0发行说明 .NET Core 2.2-&gt; 3.0 API差异 .NET Core 3.0贡献者列表 GitHub发布 .NET Core 3.0 问题的GitHub问题 关于.NET Core 3.0在深入探究.NET Core 3.0中的所有新功能之前，需要引起一些关键的改进和指导，以引起注意。这是快速打孔清单。 .NET Core 3.0已经在dot.net和Bing.com上托管了几个月，已经通过了测试。许多其他Microsoft团队很快将在生产中的.NET Core 3.0上部署大型工作负载。 在许多组件中，性能都得到了极大的提高，并且在.NET Core 3.0中的性能改进中进行了详细介绍。 C＃8添加异步流，范围/索引，更多模式和可为空的引用类型。Nullable使可以直接针对导致的代码缺陷NullReferenceException。框架库的最底层已被注释，以便知道何时可以期待null。 F＃4.7致力于通过隐式yield表达式和一些语法放松使某些事情变得容易。它还包含对的支持LangVersion，并nameof在预览中附带并打开了静态类。F＃核心库现在还针对.NET Standard 2.0。可以在发布F＃4.7中阅读更多内容。 .NET Standard 2.1增加了可以在可与.NET Core和Xamarin一起使用的代码中使用的类型集。.NET Standard 2.1包括.NET Core 2.1以后的类型。 .NET Core现在支持Windows窗体和WPF（和开源）的Windows桌面应用程序。WPF设计器是Visual Studio 2019 16.3的一部分。Windows窗体设计器仍处于预览状态，可以通过VSIX下载获得。 现在，.NET Core应用程序默认情况下具有可执行文件。在过去的发行版中，需要通过dotnet命令来启动应用，例如dotnet myapp.dll。现在可以使用特定于应用程序的可执行文件（例如myapp或）启动应用程序./myapp，具体取决于操作系统。 添加了高性能JSON API，用于读取器/写入器，对象模型和序列化方案。这些API从头开始构建，Span并在幕后使用UTF8而不是UTF16（例如string）。这些API最小化分配，从而提高了性能，减少了垃圾收集器的工作。请参阅.NET Core 3.0中JSON的未来。 默认情况下，垃圾收集器使用较少的内存，通常少得多。对于许多应用程序托管在同一服务器上的情况，此改进非常有用。垃圾收集器也进行了更新，以更好地利用64核以上的机器上的大量核。 .NET Core已针对Docker进行了强化，以使.NET应用程序在容器中可预测且有效地工作。已将容器配置为有限的内存或CPU时，垃圾收集器和线程池已更新为更好地工作。.NET Core泊坞窗映像较小，尤其是SDK映像。 现在支持Raspberry Pi和ARM芯片以支持IoT开发，包括使用远程Visual Studio调试器。可以使用新的GPIO API部署可监听传感器的应用程序，并在显示器上打印消息或图像。ASP.NET可用于将数据公开为API或允许配置IoT设备的站点。 .NET 3.0的核心是“当前”版本，将被所取代.NET 3.1的核心，目标是2019年十一月.NET 3.1的核心将是一个长期支持（LTS）版本（支持至少3年）。我们建议采用.NET Core 3.0，然后采用3.1。升级非常容易。 .NET Core 2.2将于12/23停止服务，因为它是以前的“当前”版本。请参阅.NET Core支持策略。 经过与Red Hat的多年合作，.NET Core 3.0将随RHEL 8在Red Hat Application Streams中一起提供。 对于要使用.NET Core 3.0的Windows上的Visual Studio用户，Visual Studio 2019 16.3是必需的更新。 对于要使用.NET Core 3.0的Mac用户，Visual Studio for Mac 8.3是必需的更新。 Visual Studio Code用户应始终始终使用最新版本的C＃扩展名，以确保最新的方案能够正常工作，包括针对.NET Core 3.0。 .NET Core 3.0的Azure App Service部署当前正在进行中。 .NET Core 3.0的Azure Dev Ops部署即将推出。可用时将更新。 平台支援以下操作系统支持.NET Core 3.0： Alpine: 3.9+ Debian: 9+ openSUSE: 42.3+ Fedora: 26+ Ubuntu: 16.04+ RHEL: 6+ SLES: 12+ macOS: 10.13+ Windows Client: 7, 8.1, 10 (1607+) Windows Server: 2012 R2 SP1+ 注意：Windows窗体和WPF应用程序仅在Windows上运行。 Chip support follows: Windows，macOS和Linux上的x64 Windows上的x86 Windows和Linux上的ARM32 Linux上的ARM64（内核4.14+） 注意：请确保.NET Core 3.0 ARM64部署使用Linux内核4.14版本或更高版本。例如，Ubuntu 18.04满足此要求，但16.04不满足。 WPF和Windows窗体 可以在Windows上使用.NET Core 3构建WPF和Windows Forms应用程序。从项目一开始，我们就已经制定了强大的兼容性目标，以使将桌面应用程序从.NET Framework迁移到.NET Core变得容易。我们已经听到许多开发人员的反馈，这些开发人员已经成功地将其应用程序移植到.NET Core 3.0，该过程非常简单。在很大程度上，我们按原样使用WPF和Windows窗体，并使它们在.NET Core上运行。 工程项目与之大不相同，但这是考虑该项目的好方法。 Visual Studio 2019 16.3支持创建面向.NET Core的WPF应用程序。这包括新模板以及更新的XAML设计器和XAML Hot Reload。 该设计器类似于现有的XAML设计器（以.NET Framework为目标），但是，可能会注意到体验上的一些差异。最大的技术差异是.NET Core的设计人员使用新的表面处理（wpfsurface.exe）仅运行针对.NET Core版本的运行时代码。 以前.NET Framework WPF设计器进程（xdesproc.exe）本身就是承载设计器的WPF .NET Framework进程，由于运行时不兼容，我们无法使用WPF .NET Framework进程（在本例中为Visual Studio） ）将两个版本的.NET（.NET Framework和.NET Core）加载到同一进程中。这意味着设计师的某些方面，像设计师扩展一样，不能以相同的方式工作。如果正在编写设计师扩展，我们建议阅读XAML设计器可扩展性迁移。 下图显示了在新设计器中显示的WPF应用程序： Windows Forms设计器仍处于预览状态，可以单独下载获得。 它将作为更高版本的一部分添加到Visual Studio中。该设计器当前包括对最常用控件和底层功能的支持。我们将通过每月更新不断改进设计师。 我们不建议现在将Windows Forms应用程序移植到.NET Core，特别是如果依赖设计器的话。请尝试使用设计师预览，并给我们反馈。 还可以使用.NET CLI从命令行创建和构建桌面应用程序。 例如，可以快速创建一个新的Windows窗体应用程序： 123dotnet new winforms -o myappcd myappdotnet run 可以使用相同的流程尝试WPF： 123dotnet new wpf -o mywpfappcd mywpfappdotnet run 早在2018年12月，我们就将Windows Forms和WPF开源了。很高兴看到社区以及Windows Forms和WPF团队共同努力改善这些UI框架。对于WPF，我们从GitHub存储库中的少量代码开始。此时，几乎所有WPF都已发布到GitHub，随着时间的流逝，还会有更多组件出现。与其他.NET Core项目一样，这些新存储库是.NET Foundation的一部分，并获得MIT许可。 所述System.Windows.Forms.DataVisualization包（包括图表控制）也可用于.NET核心。现在，可以在.NET Core WinForms应用程序中包含此控件。图表控件的源代码可从GitHub上的dotnet / winforms-datavisualization获得。控件已进行了迁移，以简化向.NET Core 3的移植，但不是我们希望对其进行重大更新的组件。 Windows本机互操作Windows以平面C API，COM和WinRT的形式提供了丰富的本机API。自.NET Core 1.0起，我们一直支持P / Invoke，并已添加了CoCreate COM API，激活WinRT API以及将托管代码作为COM组件作为.NET Core 3.0版本的一部分公开的功能。我们对这些功能有很多要求，因此我们知道它们会得到很多使用。 去年下半年，我们宣布已设法从.NET Core自动化Excel。那是一个有趣的时刻。在幕后，此演示使用了COM互操作功能，例如NOPIA，对象等效性和自定义编组器。现在，可以在扩展示例中自己尝试此演示和其他演示。 托管C ++和WinRT互操作对.NET Core 3.0具有部分支持，并将随.NET Core 3.1一起提供。 可空引用类型C＃8.0引入了可为空的引用类型和不可为空的引用类型，使可以对引用类型变量的属性进行重要声明： 引用不应为null。当变量不应该为null时，编译器将执行规则，以确保可以安全地取消引用这些变量，而无需先检查其是否为null。 引用可以为null。当变量可能为null时，编译器将实施不同的规则，以确保已正确检查了null引用。 与无法从变量声明中确定设计意图的早期C＃版本中，对引用变量的处理相比，此新功能具有明显的优势。通过添加可为空的引用类型，可以更清楚地声明意图，并且编译器都可以帮助正确地做到这一点并发现代码中的错误。 接口成员的默认实现如今，发布接口后，更改接口的工作就结束了：必须在不破坏现有接口的所有实现者的情况下为其添加成员。 使用C＃8.0，可以为接口成员提供主体。结果如果实现该接口的类没有实现该成员（可能是因为在编写代码时还不存在该成员），那么调用代码将只获得默认实现。 12345678910interface ILogger&#123; void Log(LogLevel level, string message); void Log(Exception ex) =&gt; Log(LogLevel.Error, ex.ToString()); // New overload&#125;class ConsoleLogger : ILogger&#123; public void Log(LogLevel level, string message) &#123; ... &#125; // Log(Exception) gets default implementation&#125; 在此示例中，ConsoleLogger该类不必实现Log(Exception)ILogger 的重载，因为它是使用默认实现声明的。现在，只要为现有实现者提供默认实现，就可以将其添加到现有的公共接口中。 异步流现在foreach可以使用来处理异步数据流IAsyncEnumerable。这个新界面正是所期望的。的异步版本IEnumerable。该语言使await foreach可以完成任务以消耗其元素。在生产方面，yield return需要生成一个异步流。这听起来可能有点复杂，但是在实践中却非常容易。 以下示例演示了异步流的产生和使用。foreach语句是异步的，它本身使用yield return为调用者生成异步流。yield return建议使用此模式- 生成异步流。 1234567async IAsyncEnumerable&lt;int&gt; GetBigResultsAsync()&#123; await foreach (var result in GetResultsAsync()) &#123; if (result &gt; 20) yield return result; &#125;&#125; 除了能await foreach，你还可以创建异步迭代器，例如返回一个迭代器IAsyncEnumerable/ IAsyncEnumerator你既可以await和yield return英寸对于那些需要处理的对象，就可以使用IAsyncDisposable，其中各种框架类型的实现，如Stream和Timer。 数和范围我们创建了新的语法和类型，可用于描述索引器，用于数组元素访问或用于公开直接数据访问的任何其他类型。这包括支持单个值（索引的通常定义）或两个值（描述范围）。 Index是描述数组索引的新类型。可以Index从一个从头算起的int 创建一个int，或者从一个从头算起的前缀^运算符创建一个int 。在以下示例中可以看到两种情况： 1234Index i1 = 3; // number 3 from beginningIndex i2 = ^4; // number 4 from endint[] a = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;Console.WriteLine($\"&#123;a[i1]&#125;, &#123;a[i2]&#125;\"); // \"3, 6\" Range相似，由两个Index值组成，一个值用于开始，一个值用于结束，并且可以使用x..y范围表达式编写。然后，可以使用进行索引，Range以生成基础数据的切片，如以下示例所示： 1var slice = a[i1..i2]; // &#123; 3, 4, 5 &#125; 使用声明是否厌倦了使用要求缩进代码的语句？不再！现在，可以编写以下代码，该代码将using声明附加到当前语句块的作用域，然后将对象放置在它的末尾。 123456789101112131415161718192021222324252627282930using System;using System.Linq;using System.Collections.Generic;using static System.Console;using System.IO;namespace usingapp&#123; class Program &#123; static void Main() &#123; var filename = \"Program.cs\"; var line = string.Empty; var magicString = \"magicString\"; var file = new FileInfo(filename); using var reader = file.OpenText(); while ((line = reader.ReadLine())!= null) &#123; if (line.Contains(magicString)) &#123; WriteLine(\"Found string\"); return; &#125; &#125; WriteLine(\"String not found\"); &#125; // reader disposed here &#125;&#125; 切换表达式任何使用C＃的人都可能喜欢switch语句的概念，而不喜欢语法。C＃8引入了开关表达式，该表达式可启用以下功能： 简短语法 返回值，因为它是一个表达式 与模式匹配完全集成 switch关键字是“ infix”，这意味着关键字位于测试值（o在第一个示例中）和案例列表之间，非常类似于表达式lambdas。 第一个示例对方法使用lambda语法，该语法与switch表达式很好地集成在一起，但不是必需的。 123456static string Display(object o) =&gt; o switch&#123; Point &#123; X: 0, Y: 0 &#125; =&gt; \"origin\", Point &#123; X: var x, Y: var y &#125; =&gt; $\"(&#123;x&#125;, &#123;y&#125;)\", _ =&gt; \"unknown\"&#125;; 在此示例中，有两种模式在起作用。o首先与Point类型的模式匹配，然后与{curly braces}内的属性模式匹配。_描述丢弃模式，它与switch语句的默认模式相同。 可以更进一步，并依靠元组的解构和参数位置，如以下示例所示： 123456789static State ChangeState(State current, Transition transition, bool hasKey) =&gt; (current, transition) switch &#123; (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; throw new InvalidOperationException($\"Invalid transition\") &#125;; 在此示例中，可以看到不需要为每种情况定义变量或显式类型。相反，编译器可以将正在测试的元组与为每种情况定义的元组进行匹配。 所有这些模式使能够编写捕获意图的声明性代码，而不是为其执行测试的过程代码。编译器负责实现无聊的过程代码，并保证始终正确执行。 在某些情况下，与两种语法样式都可以使用switch表达式和模式相比，switch语句将是更好的选择。 引入快速的JSON API.NET Core 3.0包括一个新的JSON API系列，这些系列支持读取器/写入器方案，使用文档对象模型（DOM）和序列化程序的随机访问。可能熟悉使用Json.NET。新的API旨在满足许多相同的场景，但是具有更少的内存和更快的执行速度。 可以在.NET Core 3.0中的JSON的未来中看到该计划的最初动机和说明。其中包括Json.Net的作者James Netwon-King，他解释了为什么要创建新的API，而不是扩展Json.NET。简而言之，我们想构建一个新的JSON API，以利用.NET Core中所有新的性能功能，并以此提供内联的性能。在保持兼容性的同时，不可能在像Json.NET这样的现有代码库中执行此操作。 让我们逐层快速浏览一下新的API。 Utf8JsonReader System.Text.Json.Utf8JsonReader是用于从读取的UTF-8编码JSON文本的高性能，低分配，仅转发读取器ReadOnlySpan。该Utf8JsonReader是一个基础性，低层次的类型，可以被利用来构建定制的解析器和解串器。 使用新的Utf8JsonReader读取JSON有效负载的速度比使用Json.NET的读取器快2倍。在需要将JSON令牌实现为（UTF16）字符串之前，它不会分配。 Utf8JsonWriter System.Text.Json.Utf8JsonWriter提供了一个高性能的，非缓存，只进写UTF-8从普通.NET类型编码的JSON文本一样的方式String，Int32和DateTime。像阅读器一样，编写器是基础的低级类型，可以利用它来构建自定义序列化程序。 使用新的写入JSON有效负载Utf8JsonWriter比使用from Json.NET和不分配写入器快30-80％。 JsonDocument System.Text.Json.JsonDocument提供解析JSON数据并构建只读文档对象模型（DOM）的功能，可以查询该文档对象模型以支持随机访问和枚举。 它建立在的顶部Utf8JsonReader。构成数据的JSON元素可以通过称为的属性JsonElement公开的类型来访问。 该包含JSON数组和对象普查员使用API一起JSON文本普通.NET类型转换。解析典型的JSON有效负载并使用访问其所有成员的速度比为合理大小（即&lt;1 MB）的数据分配很少时要快2-3倍。JsonDocumentRootElementJsonElementJsonDocumentJson.NET JSON序列化器 System.Text.Json.JsonSerializer高性能Utf8JsonReader和Utf8JsonWriter。它从JSON反序列化对象并将对象序列化为JSON。内存分配保持最少，并包括对Stream异步读取和写入JSON的支持。 引入新的SqlClientSqlClient是用于通过流行的.NET O / RM（例如EF Core或Dapper）之一或直接使用ADO.NET API访问Microsoft SQL Server和Azure SQL数据库的数据提供程序。现在，它将作为Microsoft.Data.SqlClient NuGet包进行发布和更新，并且受.NET Framework和.NET Core应用程序支持。通过使用NuGet，SQL团队可以更轻松地为.NET Framework和.NET Core用户提供更新。 ARM和物联网支持.NET Core运行时前滚策略更新Docker和cgroup限制默认情况下减小GC堆大小在致力于改善对docker内存限制的支持的同时，我们受到启发，进行了更通用的GC策略更新，以提高更广泛的应用程序（即使在未在容器中运行时）的内存使用率。这些更改使第0代分配预算更好地与现代处理器缓存大小和缓存层次结构保持一致。 Damian Edwards在我们的团队中注意到，ASP.NET基准测试的内存使用量减少了一半，而对其他性能指标没有负面影响。这是一个了不起的进步！正如他所说，这些是新的默认值，不需要更改代码（采用.NET Core 3.0除外）。 我们在ASP.NET基准测试中看到的内存节省可能或可能不代表将在应用程序中看到的内容。我们想听听这些更改如何减少应用程序的内存使用量。 更好地支持许多proc机器基于.NET的Windows传统，GC需要实现Windows处理器组概念以支持具有64个以上处理器的计算机。这种实现是在5到10年前在.NET Framework中完成的。使用.NET Core，我们最初选择了Linux PAL，以模仿相同的概念，即使Linux中不存在该概念。此后，我们在GC中放弃了这一概念，仅将其转换为Windows PAL。 现在，GC公开了一个配置开关GCHeapAffinitizeRanges，以在具有64个以上处理器的计算机上指定相似性掩码。Maoni Stephens在“ 使CPU数量大于64的计算机上为GC更好地配置CPU”方面写了有关此更改的内容。 GC大页面支持大页面或大页面是一项功能，操作系统可以通过该功能建立大于本机页面大小（通常为4K）的内存区域，以提高请求这些大页面的应用程序的性能。 当发生虚拟到物理地址转换时，首先会查询（通常并行）称为转换后备缓冲区（TLB）的高速缓存，以检查是否有可用的虚拟地址可用于所访问的虚拟地址，以免进行潜在的昂贵操作页表走动。每个大页面翻译都使用CPU内部的单个翻译缓冲区。该缓冲区的大小通常比本地页面大小大三个数量级；这可以提高转换缓冲区的效率，从而可以提高频繁访问的内存的性能。在具有两层TLB的虚拟机中，这一胜利更为重要。 现在可以使用GCLargePages选择功能配置GC ，以选择在Windows上分配大页面。使用大页面可以减少TLB遗漏，因此总体上可能会提高应用程序性能，但是，此功能有其自身的一组限制，应加以考虑。Bing尝试了此功能，并看到了性能改进。 .NET Core版本API我们已经改进了 .NET Core 3.0中的.NET Core版本API。他们现在返回你期望的版本信息。这些更改虽然客观上更好，但它们在技术上已被打破，并且可能会破坏依赖现有版本API来获取各种信息的应用程序。 事件管道改进事件管道现在支持多个会话。这意味着可以使用EventListener进程内消费事件，同时拥有进程外事件管道客户端。 HTTP / 2支持现在，我们在HttpClient中支持HTTP / 2。新协议是某些API的要求，例如gRPC和Apple Push Notification Service。我们希望将来有更多服务需要HTTP / 2。ASP.NET还支持HTTP / 2。 注意：首选的HTTP协议版本将通过TLS / ALPN协商，并且仅在服务器选择使用HTTP / 2时使用HTTP / 2。 分层编译分层编译是.NET Core 2.1中的一项可选功能。此功能使运行时可以在启动时最大程度地适应性地使用即时（JIT）编译器，从而获得更好的性能，并最大程度地提高吞吐量。.NET Core 3.0默认情况下启用它。去年，我们对该功能进行了许多改进，包括对各种工作负载（包括网站，PowerShell Core和Windows桌面应用程序）进行测试。性能要好很多，这就是我们默认启用它的原因。 IEEE浮点改进浮点API已更新，以符合IEEE 754-2008修订版。.NET Core浮点项目的目标是公开所有“必需的”操作，并确保它们在行为上符合IEEE规范。 .NET平台相关的本征我们添加了一些API，这些API允许访问某些面向性能的CPU指令，例如SIMD或位操作指令集。这些说明可以在某些情况下帮助实现大的性能改进，例如有效地并行处理数据。除了公开供程序使用的API之外，我们还开始使用这些说明来加速.NET库。 以下CoreCLR PR通过实现或使用演示了一些内在函数： 实现简单的SSE2硬件内在函数 实施SSE硬件内在函数 Arm64基础硬件固有特性 使用TZCNT和LZCNT进行定位{第一|最后}找到{字节|字符} Linux上现在支持支持TLS 1.3和OpenSSL 1.1.1NET Core现在可以利用OpenSSL 1.1.1中的TLS 1.3支持。每个OpenSSL团队都有TLS 1.3的多项优势： 由于减少了客户端与服务器之间的往返次数，因此缩短了连接时间 由于消除了各种过时和不安全的加密算法并加密了更多的连接握手，因此提高了安全性 .NET Core 3.0能够利用OpenSSL 1.1.1，OpenSSL 1.1.0或OpenSSL 1.0.2（在Linux系统上，无论找到哪种最佳版本）。当OpenSSL 1.1.1可用时，在使用SslProtocols时，SslStream和HttpClient类型将使用TLS 1.3。无（系统默认协议），假设客户端和服务器均支持TLS 1.3。 当支持变得可用时，.NET Core将在Windows和macOS上支持TLS 1.3（我们会自动期望）。 加密我们通过和实现了对AES-GCM和AES-CCM密码的支持。这些算法既是带有关联数据的身份验证加密（AEAD）算法，也是添加到.NET Core的第一个身份验证加密（AE）算法。System.Security.Cryptography.AesGcmSystem.Security.Cryptography.AesCcmNET Core 3.0现在支持从标准格式导入和导出非对称公钥和私钥，而无需使用X.509证书。 所有密钥类型（RSA，DSA，ECDsa，ECDiffieHellman）都支持X.509 SubjectPublicKeyInfo格式的公共密钥，以及PKCS＃8 PrivateKeyInfo和PKCS＃8 EncryptedPrivateKeyInfo格式的私有密钥。 RSA还支持PKCS＃1 RSAPublicKey和PKCS＃1 RSAPrivateKey。导出方法都产生DER编码的二进制数据，而导入方法期望相同。如果密钥以文本友好的PEM格式存储，则调用方将需要在调用import方法之前对内容进行base64解码。 可以使用System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo该类检查PKCS＃8文件。 可以分别使用System.Security.Cryptography.Pkcs.Pkcs12Info和检查PFX / PKCS＃12文件System.Security.Cryptography.Pkcs.Pkcs12Builder。 New Japanese Era (Reiwa)2019年5月1日，日本开始了一个名为Reiwa的新时代。支持日语日历的软件（如.NET Core）必须进行更新以适应Reiwa。.NET Core和.NET Framework已更新，并且可以正确处理新时代的日文日期格式和解析。 .NET依赖操作系统或其他更新来正确处理Reiwa日期。如果客户使用Windows，请下载Windows版本的最新更新。如果运行的是macOS或Linux，请下载并安装ICU 64.2版，该版本支持新的日本时代。 在.NET博客中处理日文日历中的新时代，可以获得有关.NET对新日本时代的支持的更多信息。 程序集加载上下文的改进对AssemblyLoadContext的增强： 启用命名上下文 添加了枚举ALC的功能 添加了枚举ALC中的程序集的功能 使类型具体化–实例化更加容易（简单场景不需要自定义类型） 通过AssemblyDependencyResolver与自定义一起使用AssemblyLoadContext，应用程序可以加载插件，以便从正确的位置加载每个插件的依赖项，并且一个插件的依赖项不会与另一个插件的冲突。所述AppWithPlugin样品包括具有依赖性冲突并依靠卫星组件或本机库插件的插件。 组件可卸性程序集的可卸载性是AssemblyLoadContext的一项新功能。从API角度来看，此新功能在很大程度上是透明的，仅提供了一些新API。它使加载程序上下文可以卸载，从而释放实例化类型，静态字段以及程序集本身的所有内存。应用程序应该能够通过这种机制永久加载和卸载程序集，而不会出现内存泄漏。 我们希望此新功能可用于以下情况： 需要动态插件加载和卸载的插件方案。 动态编译，运行然后刷新代码。对于网站，脚本引擎等有用。 加载程序集以进行自省（例如ReflectionOnlyLoad），尽管在许多情况下MetadataLoadContext是更好的选择。 使用MetadataLoadContext读取程序集元数据我们添加了MetadataLoadContext，它可以读取程序集元数据，而不会影响调用者的应用程序域。程序集被视为数据，包括为与当前运行时环境不同的体系结构和平台构建的程序集。MetadataLoadContext与ReflectionOnlyLoad类型重叠，该类型仅在.NET Framework中可用。 MetdataLoadContext在System.Reflection.MetadataLoadContext包中可用。这是一个.NET Standard 2.0程序包。 MetadataLoadContext的方案包括设计时功能，构建时工具和运行时点亮功能，这些功能需要将一组程序集作为数据进行检查，并在执行检查后释放所有文件锁和内存。 本机托管示例作为.NET Core 3.0的一部分，我们现在向.NET Core本机主机公开常规功能，该功能以前只能通过正式提供的.NET Core主机提供给.NET Core托管的应用程序。该功能主要与程序集加载有关。使用此功能应该可以更轻松地生成可以利用.NET Core完整功能集的本机主机。 其他API改进我们的优化Span&lt;T&gt;，Memory&lt;T&gt;以及相关的.NET 2.1的核心中引入的类型。跨距构造，切片，解析和格式化等常见操作现在可以更好地执行。此外，像String之类的类型已经得到了明显的改进，使其在Dictionary&lt;TKey, TValue&gt;与其他集合一起用作键时更加有效。无需更改任何代码即可享受这些改进。 默认情况下，应用程序现在具有本机可执行文件.NET Core应用程序现在使用本机可执行文件构建。这是依赖于框架的应用程序的新功能。到目前为止，只有独立的应用程序具有可执行文件。 可以期望这些可执行文件与其他本机可执行文件具有相同的效果，例如： 可以双击可执行文件以启动应用程序。 可以myapp.exe在Windows以及./myappLinux和macOS上使用，从命令提示符启动应用程序。 作为生成的一部分生成的可执行文件将与操作系统和CPU相匹配。例如，如果使用的是Linux x64计算机，则可执行文件将仅在该类型的计算机上运行，而不能在Windows计算机和Linux ARM计算机上运行。 这是因为可执行文件是本机代码（就像C ++）。如果要定位其他机器类型，则需要使用运行时参数进行发布。dotnet如果愿意，可以继续使用命令启动应用程序，而不使用本机可执行文件。 使用ReadyToRun图像优化.NET Core应用通过将应用程序程序集编译为ReadyToRun（R2R）格式，可以缩短.NET Core应用程序的启动时间。R2R是一种提前（AOT）编译的形式。它是.NET Core 3.0中的发布时选择功能。 注意：RuntimeIdentifier可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。 装配链接.NET core 3.0 SDK附带了一个工具，该工具可以通过分析IL和修剪未使用的程序集来减小应用程序的大小。这是.NET Core 3.0中的另一个发布时选择加入功能。 发布单文件可执行文件现在可以使用发布单个文件的可执行文件dotnet publish。这种形式的单个EXE实际上是一个自解压缩的可执行文件。它包含所有依赖项（包括本地依赖项）作为资源。在启动时，它将所有依赖项复制到一个临时目录，并在该目录中加载它们。它只需要解压缩依赖项一次。之后，启动很快，没有任何损失。 可以通过将PublishSingleFile属性添加到项目文件或在命令行上添加新的开关来启用此发布选项。 要生成一个独立的单个EXE应用程序，在这种情况下，对于64位Windows： dotnet publish -r win10-x64 /p:PublishSingleFile=true 注意：RuntimeIdentifier可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。 组合修剪器，提前编译（通过crossgen）和单个文件捆绑都是.NET Core 3.0中的所有新功能，可以一起使用，也可以单独使用。 我们希望你们中的某些人更喜欢提前编译器提供的单个exe，而不是我们在.NET Core 3.0中提供的自解压可执行方法。NET 5版本将提供提前编译器方法。 .NET 构建现在可以复制依赖项现在，在构建操作期间，dotnet构建会将应用程序的NuGet依赖项从NuGet缓存复制到构建输出文件夹。在此版本之前，这些依赖项仅作为dotnet发布的一部分进行复制。此更改使可以将构建输出xcopy复制到其他计算机。 .NET Core工具-本地安装.NET Core工具已更新，可以本地安装。与.NET Core 2.1中添加的全局工具相比，它们具有优势。 .NET Core SDK安装程序现在将就地升级Windows的.NET Core SDK MSI安装程序将开始就地升级补丁程序版本。这将减少在开发人员计算机和生产计算机上安装的SDK的数量。 .NET Core SDK大小改进.NET Core 3.0的.NET Core SDK明显较小。主要原因是我们转向了各种目的（参考程序集，框架，模板）的专用“包”，从而改变了我们构建SDK的方式。在以前的版本（包括.NET Core 2.2）中，我们从NuGet软件包构建了SDK，其中包含许多不需要的构件，并且浪费了很多空间。 Docker发布更新Microsoft团队现在正在将容器映像发布到Microsoft Container Registry（MCR）。发生此更改的主要原因有两个： 将Microsoft提供的容器映像联合到多个注册表，例如Docker Hub和Red Hat。 使用Microsoft Azure作为全局CDN，以交付Microsoft提供的容器映像。 SDK Docker映像包含PowerShell Core注意：PowerShell Core现在作为.NET Core 3.0 SDK容器映像的一部分提供。它不是.NET Core 3.0 SDK的一部分。 红帽支持2015年4月，我们宣布.NET Core将用于Red Hat Enterprise Linux。通过与Red Hat的出色工程合作，.NET Core 1.0作为组件出现在2016年6月的Red Hat软件系列中。通过与Red Hat工程师的合作，我们已经（并将继续学习！）有关发布软件的更多信息。Linux社区。 在过去的四年中，Red Hat与Microsoft在同一天发布了许多.NET Core更新和重要版本，例如2.1和2.2。借助.NET Core 2.2，红帽将其.NET Core产品扩展到包括OpenShift平台。随着RHEL 8的发布，我们很高兴在Red Hat Application Streams中提供.NET Core 2.1以及即将推出的3.0。 总结.NET Core 3.0是.NET Core的一个主要新版本，并且进行了大量改进。我们建议尽快开始采用.NET Core 3.0。 它通过许多方式极大地改进了.NET Core，例如大大减小了SDK的大小，并大大改善了对关键场景（如容器和Windows桌面应用程序）的支持。这篇文章中还没有包括很多小的改进，随着时间的推移，一定会从中受益。","categories":[{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/categories/NetCore/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://kalanliao.github.io/tags/C/"},{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/tags/NetCore/"}]},{"title":"Golang学习01","slug":"golang/golang-study-01","date":"2019-09-23T02:07:08.000Z","updated":"2019-09-23T07:06:48.010Z","comments":true,"path":"2019/09/23/golang/golang-study-01/","link":"","permalink":"https://kalanliao.github.io/2019/09/23/golang/golang-study-01/","excerpt":"","text":"首先看一下保留关键字12345break default func interfaceselect case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 内建常量,内建类型和内建函数123内建常量: true false iota nil内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptrfloat32 float64 complex128 complex64 bool byte rune string error内建函数: make len cap new append copy close delete complex real imag panic recover 变量申明123456789package main import \"fmt\" const boilingF = 212.0 func main() &#123; var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf(\"boiling point = %g°F or %g°C\\n\", f, c) // Output: // boiling point = 212°F or 100°C &#125; 上面的代码，其中boilingF是包级常量，在整个包的作用域中都可以使用而下面的f是函数级的常量，只有在这个函数的生命周期内才有作用 变量申明方式有很多种，下面举几个例子 1234567891011121314151617181920212223242526272829303132var s string fmt.Println(s) // \"\"var i, j, k int // int, int, int var b, f, s = true, 2.3, \"four\" // bool, float64, stringvar f, err = os.Open(name) // os.Open returns a file and an error//这里就和很多语言不一样，go函数一般是直接把错误返回到err里面，所以在申明的时候，要这么写var f, err，之后在下面的代码中可以判断这个err//在函数内部也可以使用下面这种简短的申明，系统会自动判断函数的类型anim := gif.GIF&#123;LoopCount: nframes&#125;freq := rand.Float64() * 3.0t := 0.0//下面是几种类型的申明可以参考一下i := 100 // an int var boiling float64 = 100 // a float64 var names []string var err error var p Pointi, j := 0, 1//有的时候我们需要交换两个变量的值i, j = j, i // 交换 i 和 j 的值//下面这段代码就用了函数内的简短申明，并判断了errf, err := os.Open(name)if err != nil &#123; return err &#125;// ...use f... f.Close() 指针12345678910111213141516171819202122//首先看一下例子x := 1p := &amp;x // p, of type *int, points to x fmt.Println(*p) // \"1\" *p = 2 // equivalent to x = 2 fmt.Println(x) // \"2\"// 如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该 整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。如果指针名字为 p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指 针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个 变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。// 变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;取地址操作。 任何类型的指针的零值都是nil。如果p != nil测试为真，那么p是指向某个有效变量。指针之间也是可 以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。var x, y int fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == nil) // \"true false false\"func incr(p *int) int &#123; *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！ return *p &#125;v := 1incr(&amp;v) // side effect: v is now 2//上面这段代码中，传入incr函数的是一个指针这有点像C++的用法，如果在C#中，就要用到out 和ref关键字","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kalanliao.github.io/tags/Golang/"}]},{"title":"Enum中FlagsAttribute的应用","slug":"netcore/netcore3-0-enum-flagsattr","date":"2019-09-23T01:53:03.000Z","updated":"2019-09-23T09:21:10.310Z","comments":true,"path":"2019/09/23/netcore/netcore3-0-enum-flagsattr/","link":"","permalink":"https://kalanliao.github.io/2019/09/23/netcore/netcore3-0-enum-flagsattr/","excerpt":"","text":"应用Enum的FlagsAttribute标签能做很多应用，可以使枚举获得多个判断的效果下面这段代码： 1234567891011[Flags] enum WeekDays &#123; Monday = 0x1, Tuesday = 0x2, Wednesday = 0x4, Thursday = 0x8, Friday = 0x10, Saturday = 0x20, Sunday = 0x40 &#125; 同样的我们也可以这么写 1234567891011[Flags] public enum WeekDays &#123; Monday = 1, Tuesday = 2, Wednesday = 4, Thursday = 8, Friday = 16, Saturday = 32, Sunday = 64 &#125; 这里会用到我们位运算的特性 123456789101112131415161718192021222324WeekDays wds = WeekDays.Monday | WeekDays.Sunday | WeekDays.Tuesday;/* 我们来看看计算过程: * 或运算: 0000 0001 --星期一 0x1 或 0010 0000 --星期六 0x20 或 0000 0010 --星期二 0x2 = 0010 0011 = 35 *换句话说: 某个位是1就代表了这个位上的值在枚举中存在 */Console.WriteLine(\"这3天组合Int为: \" + (int)wds);/*利用上面规则来判断枚举值中是否包含某个枚举值就轻而易举*/if ((wds &amp; WeekDays.Monday) != 0) Console.WriteLine(\"星期一是其中一天\");if ((wds &amp; WeekDays.Saturday) == 0) Console.WriteLine(\"星期六不是其中一天\");//(补充)如果将某个值去掉的话可以按照原来采用这次方式/* 将星期六从枚举变量中去掉 * 0010 0011 * &amp;1011 1111 (~WeekDays.Monday)取反 * =0000 0011 这样就把星期一去掉啦!*/wds = wds &amp; (~WeekDays.Monday);Console.WriteLine(\"去掉星期一后的效果: \" + wds); 到这里我们看到可以联想到可以用这个枚举来做一些简单的页面权限的判断比如我们有下面这些权限 12345678910111213141516171819202122[Flags]public enum Permissions&#123; [Description(\"未設定\")] None = 0, [Description(\"建立\")] Create = 1, [Description(\"讀取\")] Read = 2, [Description(\"更新\")] Update = 4, [Description(\"刪除\")] Delete = 8, [Description(\"所有功能\")] All = Create | Read | Update | Delete&#125; 通过下面的判断方法来进行权限判断 1234567891011Permissions permission = Permissions.None;permission = permission | Permissions.Create;MessageBox.Show(permission.ToString());// Result: Createpermission = permission | Permissions.Read;permission = permission | Permissions.Update;MessageBox.Show(permission.ToString());// Result: Create, Read, Updatepermission = (permission &amp; (Permissions.All ^ Permissions.Read));MessageBox.Show(permission.ToString());// Result: Create, Update","categories":[{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/categories/NetCore/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://kalanliao.github.io/tags/C/"},{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/tags/NetCore/"}]},{"title":"马云离职语录","slug":"creed/Jack-Ma01","date":"2019-09-19T07:58:31.000Z","updated":"2019-09-23T02:01:49.177Z","comments":true,"path":"2019/09/19/creed/Jack-Ma01/","link":"","permalink":"https://kalanliao.github.io/2019/09/19/creed/Jack-Ma01/","excerpt":"","text":"马云：我最遗憾的错误01年，我犯了一个错误，我告诉我的18位共同创业同仁，他们只能做小组经理，而所有的副总裁都得从外面聘请。现在十年过去了，我从外面聘请的人才都走了，而我之前曾怀疑过其能力的人都成了副总或董事。我相信两个信条：态度比能力重要，选择同样也比能力重要！ 马云：不能统一人的思想，但可以统一人的目标千万不要相信你能统一人的思想，那是不可能的。30%的人永远不可能相信你，不要让你的同事为你干活，而让他们为我们的共同目标干活。团结在一个共同的目标下，要比团结在一个人周围容易的多。 马云提醒：细节好的人格局一般都差 有人觉得我牛，6分钟说服了孙正义，其实是他说服了我。见孙正义之前，我在硅谷至少被拒绝了40次。 做企业赢在细节，输在格局。 格局，“格”是人格，“局”是胸怀，细节好的人格局一般都差，格局好的人从来不重细节，两个都干好，那叫太有才！ 马云：领导比员工多什么？领导永远不要跟下属比技能，下属肯定比你强；如果不比你强，说明你请错人了。 要比眼光：比他看得远； 要比胸怀：领导的胸怀是委屈撑大的，要能容人所不容； 要比实力：抗失败的能力比他强；一个优秀的领导人的素质就是眼光、胸怀和实力。 马云：中国商人千万别在“红道”上混 人一辈子要明白钱和权两个东西是绝对不要碰在一起，当了官永远不要想有钱，当了商人千万别想权； 钱和权这两个东西碰在一起就是炸药和雷管碰在一起，必然要爆炸； 胡雪岩的悲哀就在于他是红顶商人；④中国商人千万别在“红道”上混。 马云：年轻人必须思考的4大问题 什么是失败？放弃就是最大的失败。 什么叫坚强？经历许多磨难、委屈、不爽，你才知道什么叫坚强。 你的职责是什么？比别人多勤奋一点、多努力一点、多一点理想，这就是你的职责。 傻瓜用嘴讲话，聪明人用脑袋讲话，智者用心讲话。 马云：人生在世在做人，不是做事我跟自己讲我们到这个世界上不是来工作的，我们是来享受人生的，我们是来做人不是做事。 如果一辈子都做事的话，忘了做人，将来一定会后悔。 不管事业多成功、多伟大、多了不起，记住我们到这个世界就是享受经历这个人生的体验。 忙着做事一定会后悔。 马云：高手的竞争论 一定要争得你死我活的商战，是最愚蠢的。 眼睛中全是敌人，外面就全是敌人。 竞争的时候不要带仇恨，带仇恨一定失败。 竞争乐趣就像下棋一样，你输了，我们再来过，两个棋手不能打架。 真正做企业是没有仇人的，心中无敌，天下无敌。 马云：别把抱怨当习惯人是退化最严重的动物。跟兽比人很“弱肢”，和狗比人很“闻盲”，但人类“进化”了抱怨。 偶尔为之无大碍，但当抱怨成习惯，就如喝海水，喝的越多渴得越厉害。 最后发现，走在成功路上的，都是些不抱怨的“傻子们”。 世界不会记得你说了什么，但一定不会忘记你做了什么！ 马云给初创企业者的忠告 大家看不清的机会，才是真正的机会。 让员工笑着干活。 客户第一、员工第二、股东第三。 抢在变化之前先变。 忘掉money，忘掉赚钱。 小聪明不如傻坚持。 心态决定姿态，姿态决定状态。 马云谈创业 一个好的东西往往是说不清楚的，说得清楚的往往不是好东西！ 创业要找最合适的人，不一定要找最成功的人。 这世界最不可靠的东西就是关系。 免费是世界上最昂贵的东西。 今天很残酷，明天更残酷，后天很美好。 马云“四不”创业智慧 创业最怕就是看不见，看不起，看不懂，跟不上； 看不见对手在哪里，看不起对手，看不懂对手为什么可以变得那么强，然后就跟不上了； 即使对手很弱小，也一定要把对方看的很强大，即使对手很强大，也不一定要把自己看的很弱小。 马云当你决定要创业时便意味着： 没有了稳定的收入；②没有了请假的权利；③没有了得红包的机会。 然而却更意味着： 收入不再受限制；②时间运用更有效；③手心向下不求人。 想法若不同，结果便不同；选择不一样，生活才变样。 马云谈机会如果一个方案有90%的人说“好”的话，我一定要把它扔到垃圾桶里去。 因为这么多人说好的方案，必然有很多人在做了，机会肯定不会是我们的了。","categories":[{"name":"信条","slug":"信条","permalink":"https://kalanliao.github.io/categories/信条/"}],"tags":[{"name":"马云","slug":"马云","permalink":"https://kalanliao.github.io/tags/马云/"},{"name":"Jack MA","slug":"Jack-MA","permalink":"https://kalanliao.github.io/tags/Jack-MA/"}]},{"title":".NET Core 3.0 可回收程序集加载上下文","slug":"netcore/netcore3-0-context-gc","date":"2019-09-19T02:12:16.000Z","updated":"2019-09-24T05:26:29.898Z","comments":true,"path":"2019/09/19/netcore/netcore3-0-context-gc/","link":"","permalink":"https://kalanliao.github.io/2019/09/19/netcore/netcore3-0-context-gc/","excerpt":"","text":"前世今生.NET诞生以来，程序集的动态加载和卸载都是一个Hack的技术，之前的NetFx都是使用AppDomain的方式去加载程序集，然而AppDomain并没有提供直接卸载一个程序集的API，而是要卸载整个AppDomain才能卸载包含在其中的所有程序集。然而卸载整个CurrentAppDomain会使程序不能工作。 可能有人另辟西经，创建别一个AppDomain来加载/卸载程序集，但是由于程序集之间是不能跨域访问的，也导致只能通过Remote Proxy的方式去访问，这样在类型创建和使用上带来了一定的难度也是类型的继承变得相当复杂。 .NET Core中一直没有AppDomain的支持。但是在.NET Core 3.0中，我最期待的一个特性就是对可收集程序集的支持(Collectible AssemblyLoadContext)。 众所周知.NET Core中一直使用AssemblyLoadContext的API，来进行程序集的动态加载，但是并没有提供Unload的方法，此次升级更新了这方面的能力。 AssemblyLoadContext其实这次AssemblyLoadContext的设计，我认为更像是Java中ClassLoader的翻版，可以说非常类似。在使用过程中自定义AssemblyLoadContext可以内部管理其中的程序集，并对整体Context进行Unload。使用AssemblyLoadContext也可以避免程序集名称和版本的冲突。 Getting Started.NET Core 3.0还没有正式版，所有要使用预览版的SDK完成以下实例。我使用的是.NET Core SDK 3.0.100-preview-009812 dotnet new globaljson --sdk-version 3.0.100-preview-009812 AssemblyLoadContext是一个抽象类的，我们需要子类化。下面显示的是我们创建自定义AssemblyLoadContext的方法,实现一个可回收的Context需要在构造器中指定isCollectible: true ： 123456789public class CollectibleAssemblyLoadContext : AssemblyLoadContext&#123; public CollectibleAssemblyLoadContext() : base(isCollectible: true) &#123; &#125; protected override Assembly Load(AssemblyName assemblyName) &#123; return null; &#125;&#125; 使用netstandard2.0创建一个library 1234567891011using System;namespace SampleLibrary&#123; public class SayHello &#123; public void Hello(int iteration) &#123; Console.WriteLine($\"Hello &#123;iteration&#125;!\"); &#125; &#125;&#125; 测试Load/Unload 12345678910111213var context = new CollectibleAssemblyLoadContext();var assemblyPath = Path.Combine(Directory.GetCurrentDirectory(),\"SampleLibrary.dll\");using (var fs = new FileStream(assemblyPath, FileMode.Open, FileAccess.Read))&#123; var assembly = context.LoadFromStream(fs); var type = assembly.GetType(\"SampleLibrary.SayHello\"); var greetMethod = type.GetMethod(\"Hello\"); var instance = Activator.CreateInstance(type); greetMethod.Invoke(instance, new object[] &#123; i &#125;);&#125;context.Unload();GC.Collect();GC.WaitForPendingFinalizers(); 当执行GC收回后，加载的程序集会被完全的回收。","categories":[{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/categories/NetCore/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://kalanliao.github.io/tags/C/"},{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/tags/NetCore/"}]},{"title":"正则大全收藏","slug":"collect/regex","date":"2019-09-18T03:01:34.000Z","updated":"2019-09-23T02:01:55.951Z","comments":true,"path":"2019/09/18/collect/regex/","link":"","permalink":"https://kalanliao.github.io/2019/09/18/collect/regex/","excerpt":"","text":"校验数字的表达式123456789101112131415161718192021222324252627282930313233343536371 数字：^[0-9]*$2 n位的数字：^\\d&#123;n&#125;$3 至少n位的数字：^\\d&#123;n,&#125;$4 m-n位的数字：^\\d&#123;m,n&#125;$5 零和非零开头的数字：^(0|[1-9][0-9]*)$6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d&#123;1,2&#125;)?$8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9])&#123;1,3&#125;$ 或 ^+?[1-9][0-9]*$12 非零的负整数：^-[1-9][]0-9&quot;$ 或 ^-[1-9]\\d$13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$17 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$18 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 校验字符的表达式12345678910111213141516171819202122231 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$3 长度为3-20的所有字符：^.&#123;3,20&#125;$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$11 可以输入含有^%&amp;&apos;,;=?$\\&quot;等字符：[^%&amp;&apos;,;=?$\\x22]+12 禁止输入含有~的字符：[^~\\x22]+ 特殊需求表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3 InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$6 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;7 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).&#123;8,10&#125;$12 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\\u4e00-\\u9fa5]27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))","categories":[{"name":"Collect","slug":"Collect","permalink":"https://kalanliao.github.io/categories/Collect/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://kalanliao.github.io/tags/regex/"}]},{"title":"javascript学习-02(跨域原理)","slug":"javascript/javascript-study-02","date":"2019-09-18T01:55:49.000Z","updated":"2019-09-23T02:02:25.461Z","comments":true,"path":"2019/09/18/javascript/javascript-study-02/","link":"","permalink":"https://kalanliao.github.io/2019/09/18/javascript/javascript-study-02/","excerpt":"","text":"跨域请求的含义浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。 一般的，只要网站的 协议名protocol、 主机host、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。这也是我们下面实践的理论基础。我们利用 NodeJs 创建了两个服务器，分别监听 3000、 3001 端口（下面简称 服务器3000 与 服务器3001 ），由于端口号不一样，这两个服务器以及服务器上页面通信构成了跨域请求。 在服务器3000 有一个登录页面，页面的请求代码是这样的 12345678910111213141516171819202122$(function() &#123; $(\"#submit\").click(function() &#123; var data = &#123; name: $(\"#name\").val(), id: $(\"#id\").val() &#125;; $.ajax(&#123; type: 'POST', data: data, url: 'http://localhost:3000/ajax/deal', dataType: 'json', cache: false, timeout: 5000, success: function(data) &#123; console.log(data) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log('error ' + textStatus + ' ' + errorThrown); &#125; &#125;); &#125;);&#125;); 处理函数为： 123456789pp.post('/ajax/deal', function(req, res) &#123; console.log(\"server accept: \", req.body.name, req.body.id) var data = &#123; name: req.body.name + ' - server 3000 process', id: req.body.id + ' - server 3000 process' &#125; res.send(data) res.end()&#125;) 结果为：此处数据处理成功。 由于数据请求一般都是由页面发送数据字段，服务器根据这些字段作相应的处理，如数据库查询，字符串操作等等。所以我们这里简单的处理数据（在数据后面加上字符串‘server 3000 process’），并且返回给浏览器，表示数据经过服务器端处理。如果让 服务器3000 上的页面向 服务器 3001 发起请求会怎样呢？ 将请求页面中的 ajax 请求路径改为： 12345$.ajax(&#123; ... url: 'http://localhost:3001/ajax/deal', ...&#125;); 服务器3001 对应的处理函数与 服务器3000 类似： 123456789app.post('/ajax/deal', function(req, res) &#123; console.log(\"server accept: \", req.body.name, req.body.id) var data = &#123; name: req.body.name + ' - server 3001 process', id: req.body.id + ' - server 3001 process' &#125; res.send(data) res.end()&#125;) 结果证明了我们上面所说的端口号不同，发生了跨域请求的调用。 需要注意的是，服务器 3001 控制台有输出： server accept: chiaki 3001这说明跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。 利用 JSONP 实现跨域调用说道跨域调用，可能大家首先想到的或者听说过的就是 JSONP 了。 什么是JSONP来看一下原文 JSONP (JSON with Padding or JSON-P) is a JSON extension used by web developers to overcome the cross-domain restrictions imposed by browsers’ same-origin policy that limits access to resources retrieved from origins other than the one the page was served by. In layman’s terms, one website cannot just simply access the data from another website. It was developed because handling a browsers’ same origin policy can be difficult, so using JSONP abstracts the difficulties and makes it easier. JSON stands for “JavaScript Object Notation”, a format by which object fields are represented as key-value pairs which is used to represent data.JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 XmlHttpRequest 对象受到同源策略的影响，而 &lt;script&gt; 标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。 使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用我们先从简单的实现开始，利用 jQuery 中的 $.ajax 来实现上诉的跨域调用。 依然是上面的例子，我们将 服务器 3000 上的请求页面的 JavaScript 代码改为： 123456789101112131415161718192021222324252627// 回调函数function jsonpCallback(data) &#123; console.log(\"jsonpCallback: \" + data.name)&#125;$(\"#submit\").click(function() &#123; var data = &#123; name: $(\"#name\").val(), id: $(\"#id\").val() &#125;; $.ajax(&#123; url: 'http://localhost:3001/ajax/deal', data: data, dataType: 'jsonp', cache: false, timeout: 5000, // jsonp 字段含义为服务器通过什么字段获取回调函数的名称 jsonp: 'callback', // 声明本地回调函数的名称，jquery 默认随机生成一个函数名称 jsonpCallback: 'jsonpCallback', success: function(data) &#123; console.log(\"ajax success callback: \" + data.name) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log(textStatus + ' ' + errorThrown); &#125; &#125;);&#125;); 服务器 3001 上对应的处理函数为： 123456789app.get('/ajax/deal', function(req, res) &#123; console.log(\"server accept: \", req.query.name, req.query.id) var data = \"&#123;\" + \"name:'\" + req.query.name + \" - server 3001 process',\" + \"id:'\" + req.query.id + \" - server 3001 process'\" + \"&#125;\" var callback = req.query.callback var jsonp = callback + '(' + data + ')' console.log(jsonp) res.send(jsonp) res.end()&#125;) 这里一定要注意 data 中字符串拼接，不能直接将 JSON 格式的 data 直接传给回调函数，否则会发生编译错误： parsererror Error: jsonpCallback was not called。 其实脑海里应该有一个概念：利用 JSONP 格式返回的值一段要立即执行的 JavaScript 代码，所以不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理。 处理结果如下所示： 使用 &lt;script&gt; 标签原生实现 JSONP经过上面的事件，你是不是觉得 JSONP 的实现和 Ajax 大同小异？ 其实，由于实现的原理不同，由 JSONP 实现的跨域调用不是通过 XmlHttpRequset 对象，而是通过 script 标签，所以在实现原理上，JSONP 和 Ajax 已经一点关系都没有了。看上去形式相似只是由于 jQuery 对 JSONP 做了封装和转换。 比如在上面的例子中，我们假设要传输的数据 data 格式如下： 1234&#123; name: \"chiaki\", id\": \"3001\"&#125; 那么数据是如何传输的呢？HTTP 请求头的第一行如下： GET /ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032 HTTP/1.1 可见，即使形式上是用 POST 传输一个 JSON 格式的数据，其实发送请求时还是转换成 GET 请求。 其实如果理解 JSONP 的原理的话就不难理解为什么只能使用 GET 请求方法了。由于是通过 script 标签进行请求，所以上述传输过程根本上是以下的形式： &lt;script src = &#39;http://localhost:3001/ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032&#39;&gt;&lt;/script&gt; 这样从服务器返回的代码就可以直接在这个 script 标签中运行了。下面我们自己实现一个 JSONP： 服务器 3000请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback： 123function jsonpCallback(data) &#123; console.log(\"jsonpCallback: \"+data.name)&#125; 服务器 3000请求页面还包含一个 script 标签： &lt;script src = &#39;http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback&#39;&gt;&lt;/script&gt; 服务器 3001上对应的处理函数： 123456789app.get('/jsonServerResponse', function(req, res) &#123; var cb = req.query.jsonp console.log(cb) var data = 'var data = &#123;' + 'name: $(\"#name\").val() + \" - server 3001 jsonp process\",' + 'id: $(\"#id\").val() + \" - server 3001 jsonp process\"' + '&#125;;' var debug = 'console.log(data);' var callback = '$(\"#submit\").click(function() &#123;' + data + cb + '(data);' + debug + '&#125;);' res.send(callback) res.end()&#125;) 与上面一样，我们在所获取的参数后面加上 “ – server 3001 jsonp process” 代表服务器对数据的操作。从代码中我么可以看到，处理函数除了根据参数做相应的处理，更多的也是进行字符串的拼接。 最终的结果为： JSONP 总结至此，我们了解了 JSONP 的原理以及实现方式，它帮我们实现前端跨域请求，但是在实践的过程中，我们还是可以发现它的不足： 只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。 使用 CORS 实现跨域调用什么是 CORS？Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。 CORS 的实现还是以 服务器 3000 上的请求页面向 服务器 3001 发送请求为例。 服务器 3000 上的请求页面 JavaScript 不变，如下： 12345678910111213141516171819202122$(function() &#123; $(\"#submit\").click(function() &#123; var data = &#123; name: $(\"#name\").val(), id: $(\"#id\").val() &#125;; $.ajax(&#123; type: 'POST', data: data, url: 'http://localhost:3001/cors', dataType: 'json', cache: false, timeout: 5000, success: function(data) &#123; console.log(data) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log('error ' + textStatus + ' ' + errorThrown); &#125; &#125;); &#125;);&#125;); 服务器 3001上对应的处理函数： 1234567891011121314app.post('/cors', function(req, res) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", ' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); var data = &#123; name: req.body.name + ' - server 3001 cors process', id: req.body.id + ' - server 3001 cors process' &#125; console.log(data) res.send(data) res.end()&#125;) 在服务器中对返回信息的请求头进行了设置。 最终的结果为： CORS 中属性的分析Access-Control-Allow-Origin The origin parameter specifies a URI that may access the resource. The browser must enforce this. For requests without credentials, the server may specify “*” as a wildcard, thereby allowing any origin to access the resource. Access-Control-Allow-Methods Specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above. Access-Control-Allow-Headers Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.CORS 与 JSONP 的对比1.CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。 2.CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。 3.JSONP 可以在不支持 CORS 的老旧浏览器上运作。 一些其它的跨域调用方式window.namewindow对象有个name属性，该属性有个特征：即在一个窗口 (window) 的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 window.postMessage()这个方法是 HTML5 的一个新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。 参考：https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kalanliao.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://kalanliao.github.io/tags/js/"}]},{"title":".NetCore3.0预览","slug":"netcore/netcore3.0_preview","date":"2019-09-17T08:55:49.000Z","updated":"2019-09-23T02:00:08.162Z","comments":true,"path":"2019/09/17/netcore/netcore3.0_preview/","link":"","permalink":"https://kalanliao.github.io/2019/09/17/netcore/netcore3.0_preview/","excerpt":"","text":".NET Core 3.0 正式发布将在.NET Conf 上发布，.NET Conf 时间是9月23日至25日。 Visual Studio 2019 16.3预览版3和Visual Studio for Mac 8.3支持.NET Core 3.0 ，这些版本也同时发布。 从.NET Core 3.0 Preview 7就可用于生产，目前dotnet官网就是使用 https://dotnet.microsoft.com/ Powered by .NET Core 3.0.0-preview9-19423-09。 博客园也升级为.NET Core 3.0 Preview 8，目前运行算是良好。 下面实际体验.NET Core 3.0 新特性。 .NET Core 3.0System.Text.Json1234567891011121314public class Person&#123; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public DateTime? BirthDay &#123; get; set; &#125;&#125;//转成对象string json = ...Person person = JsonSerializer.Parse&lt;Person&gt;(json);//转成json字符串Person person = ...string json = JsonSerializer.ToString(person); .NET Standard 2.1要以.NET Standard 2.1为目标，必须编辑项目文件并将TargetFramework属性更改为netstandard2.1： .NET Framework不支持.NET Standard 2.1。 12345&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; Microsoft.Data.SqlClientMicrosoft.Data.SqlClient是Microsoft Sql Server的数据提供程序。 它是两个System.Data.SqlClient组件的联合体，独立存在于.NET Framework和.NET Core中。 最新版本安装 Install-Package Microsoft.Data.SqlClient https://github.com/dotnet/SqlClient 发布成单个程序dotnet publish -r win10-x64 /p:PublishSingleFile=true Alpine Docker images.NET Core and ASP.NET Core on ARM64 docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8 docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8 dotnet-counters安装 ： dotnet tool install –global dotnet-counters –version 3.0.0-preview8.19412.1 使用示例： 显示所有信息 dotnet-counters monitor –process-id 1902 System.Runtime 显示CPU使用 GC 及异常数 dotnet-counters monitor –process-id 1902 System.Runtime[cpu-usage,gc-heap-size,exception-count] 官方文档：https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md ReadyToRun你可以通过将应用程序集编译为ReadyToRun（R2R）格式来缩短.NET Core应用程序的启动时间。R2R是一种提前（AOT）编译的形式。 示例提升： 仅限IL的应用： 启动时间：1.9秒内存使用量：69.1 MB应用程序大小：150 MB使用ReadyToRun图像： 启动时间：1.3秒。内存使用量：55.7 MB应用程序大小：156 MB要启用ReadyToRun编译 需要以下操作： 将PublishReadyToRun属性设置为true。 使用显式发布RuntimeIdentifier。 1234567&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;true&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; dotnet publish -r win-x64 -c Release ReadyToRun编译器目前不支持交叉定位。需要在给定目标上进行编译。例如，如果想要Windows x64的R2R程序，则需要在该环境中运行publish命令。 IL linker使用IL linker 可以将程序大小从大约68MB减少到大约28MB dotnet publish -r win10-x64 -c Release /p:PublishTrimmed=true /p:PublishSingleFile=true HttpClient支持HTTP/2123456789101112var client = new HttpClient() &#123; BaseAddress = new Uri(\"https://localhost:5001\") &#125;;// HTTP/1.1 requestusing (var response = await client.GetAsync(\"/\"))&#123; Console.WriteLine(response.Content);&#125;// HTTP/2 requestusing (var request = new HttpRequestMessage(HttpMethod.Get, \"/\") &#123; Version = new Version(2, 0) &#125;)using (var response = await client.SendAsync(request))&#123; Console.WriteLine(response.Content);&#125; ASP.NET Core 3.0ASP.NET Core 3.0中主要更新还是Blazor和gRPC BlazorBlazor 是一个用于使用 .NET 生成交互式客户端 Web UI 的框架： 使用 C# 代替 JavaScript 来创建丰富的交互式 UI。 共享使用 .NET 编写的服务器端和客户端应用逻辑。 将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。 使用 .NET 进行客户端 Web 开发可提供以下优势： 使用 C# 代替 JavaScript 来编写代码。 利用现有的 .NET 库生态系统。 在服务器和客户端之间共享应用逻辑。 受益于 .NET 的性能、可靠性和安全性。 始终高效支持 Windows、Linux 和 macOS 上的 Visual Studio。 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。 Blazor 应用基于组件 。 Blazor 中的组件是指 UI 元素，例如，页面、对话框或数据输入窗体。 组件类通常以 Razor 标记页（文件扩展名为 .razor ）的形式编写。 Blazor 中的组件有时被称为 Razor 组件 。 Razor 标记演示组件： 1234567891011121314151617&lt;div&gt; &lt;h1&gt;@Title&lt;/h1&gt; @ChildContent &lt;button @onclick=\"OnYes\"&gt;Yes!&lt;/button&gt;&lt;/div&gt;@code &#123; [Parameter] public string Title &#123; get; set; &#125; [Parameter] public RenderFragment ChildContent &#123; get; set; &#125; private void OnYes() &#123; Console.WriteLine(\"Write to the console in C#! 'Yes' button was selected.From LineZero\"); &#125; 对话框的正文内容 (ChildContent) 和标题 (Title) 由在其 UI 中使用此组件的组件提供。 OnYes 是由按钮的 onclick 事件触发的 C# 方法。 Blazor 使用 UI 构成的自然 HTML 标记。 HTML 元素指定组件，并且标记的特性将值传递给组件的属性。 在以下示例中，Index 组件中使用上面的 Dialog 组件。 1234567@page \"/\"&lt;h1&gt;Hello, world!&lt;/h1&gt;Welcome to your new app.&lt;Dialog Title=\"Blazor\"&gt; Do you want to &lt;i&gt;learn more&lt;/i&gt; about Blazor? From LineZero&lt;/Dialog&gt; 更多官方介绍：https://docs.microsoft.com/zh-cn/aspnet/core/blazor/get-started?view=aspnetcore-3.0&amp;tabs=visual-studio gRPCgRPC 的主要优点是： 现代高性能轻量级 RPC 框架。 协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。 可用于多种语言的工具，以生成强类型服务器和客户端。 支持客户端、服务器和双向流式处理调用。 使用 Protobuf 二进制序列化减少对网络的使用。 这些优点使 gRPC 适用于： 效率至关重要的轻量级微服务。 需要多种语言用于开发的 Polyglot 系统。 需要处理流式处理请求或响应的点对点实时服务。 虽然 C# 实现目前在官方 gRPC 上有介绍，但当前实现依赖于用 C (gRPC C-core) 编写的本机库。 目前正在基于 Kestrel HTTP 服务器和完全托管的 ASP.NET Core 实现gRPC。","categories":[{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/categories/NetCore/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://kalanliao.github.io/tags/C/"},{"name":"NetCore","slug":"NetCore","permalink":"https://kalanliao.github.io/tags/NetCore/"}]},{"title":"javascript学习-01(Console)","slug":"javascript/javascript-study-01","date":"2019-09-17T06:55:49.000Z","updated":"2019-09-19T02:34:06.002Z","comments":true,"path":"2019/09/17/javascript/javascript-study-01/","link":"","permalink":"https://kalanliao.github.io/2019/09/17/javascript/javascript-study-01/","excerpt":"","text":"Console我们经常会在浏览器中使用console.log来进行调试和参数的输出查看，但是console其实是一个非常丰富的封装，其中还有很多的方法，今天就来介绍一下。首先，我们先看一下console的代码 下面就介绍一下，我们会用到的可以提高我们开发效率，调试效率的方法。 console.log()123456//平时我们使用的时候会这样console.log(\"测试内容不要当真\");//或者这样console.log(1,2,3,4)//或者这样console.log(&#123;name:1&#125;) 上面我们使用的格式为console.log(object),console.log(object, otherObject, string)除了这些基础用法还有比较好玩的用法console.log(msg, values),这个格式的用法有点像C++的printf,C#的Console.Write()等那么我们来看看怎么使用 12345//首先我们使用了3种占位符console.log(\"我今天吃了%o,你吃了%d顿,你叫%s.\", \"Skittles\", 22,\"Kalan\");//%o的复杂传值console.log(\"abc %o\",&#123;name:1&#125;) 我们看一下效果可以看到%o这个是对象占位符,%s这个是字符串占位符,%d这个是数字占位符 下面我们讲解一个更好玩的占位符%c，先上代码 1234console.log( \"我爱你 %c路西\" one day, \"color: Red; background-color: orange; padding: 2px 5px; border-radius: 2px\"); 看到这里，应该明白，这个占位符当你使用之后，后面所有的文字都将根据此CSS渲染%o除外 console.dir()123//直接上例子console.dir(document.getElementsByClassName(\"full\")[0])console.log(document.getElementsByClassName(\"full\")[0]) 我们看到结果console.log直接输出的html，而console.dir输出的是DOM结构树对象 console.warn()这个函数直接会输出一个警告框，可以定位到输出位置 console.table()这个函数能更好的显示列表型数据，我们用console.log显示对比一下 12console.table([1,2,3],[2,3,4])console.table(&#123;name:1,age:2&#125;,&#123;name:11,age:22&#125;,&#123;name:11,age:22&#125;) console.assert() 可以传递2个参数：如果为false会输出Assertion failed和第二个参数（如上图所示） console.countcount只是作为一个计数器，或者作为一个命名计数器，可以统计代码被执行的次数。 1234567891011for (let i = 0; i &lt; 10000; i++) &#123; if (i % 2) &#123; console.count(\"odds\"); &#125; if (!(i % 5)) &#123; console.count(\"multiplesOfFive\"); &#125; if (isPrime(i)) &#123; console.count(\"prime\"); &#125;&#125; console.trace()trace 可以调试模块之间的调用 1234567891011export default class CupcakeService &#123; constructor(dataLib) &#123; this.dataLib = dataLib; if(typeof dataLib !== 'object') &#123; console.log(dataLib); console.trace(); &#125; &#125; ...&#125; 这里使用 console.log()仅告诉我们传递数据dataLib是什么 ，而没有具体的传递的路径。不过，console.trace()会非常清楚地告诉我们问题出在 Dashboard.js，我们可以看到是 new CupcakeService(false)导致错误。 console.time()console.time() 是一个用于跟踪操作时间的专用函数，它是跟踪 JavaScript 执行时间的好方法。 123456789101112131415function slowFunction(number) &#123; var functionTimerStart = new Date().getTime(); // something slow or complex with the numbers. // Factorials, or whatever. var functionTime = new Date().getTime() - functionTimerStart; console.log(`Function time: $&#123;functionTime&#125;`);&#125;var start = new Date().getTime();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;var time = new Date().getTime() - start;console.log(`Execution time: $&#123;time&#125;`); 这是一种老派的做法，我们使用 console.time()来简化以上代码。 123456789101112const slowFunction = number =&gt; &#123; console.time(\"slowFunction\"); // something slow or complex with the numbers. // Factorials, or whatever. console.timeEnd(\"slowFunction\");&#125;;console.time();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;console.timeEnd(); console.group()12345678910111213// this is the global scopelet number = 1;console.group(\"OutsideLoop\");console.log(number);console.group(\"Loop\");for (let i = 0; i &lt; 5; i++) &#123; number = i + number; console.log(number);&#125;console.groupEnd();console.log(number);console.groupEnd();console.log(\"All done now\"); 输出如下： 123456789101112131415161718class MyClass &#123; constructor(dataAccess) &#123; console.group(\"Constructor\"); console.log(\"Constructor executed\"); console.assert( typeof dataAccess === \"object\", \"Potentially incorrect dataAccess object\" ); this.initializeEvents(); console.groupEnd(); &#125; initializeEvents() &#123; console.group(\"events\"); console.log(\"Initialising events\"); console.groupEnd(); &#125;&#125;let myClass = new MyClass(false);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kalanliao.github.io/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://kalanliao.github.io/tags/js/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-17T03:13:05.858Z","updated":"2019-09-17T05:38:34.554Z","comments":true,"path":"2019/09/17/hello-world/","link":"","permalink":"https://kalanliao.github.io/2019/09/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"测试","slug":"测试","permalink":"https://kalanliao.github.io/categories/测试/"}],"tags":[]}]}